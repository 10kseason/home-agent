# VRAM 정책 로직 · 번역 파이프라인 · 클립보드 복사

*(STT는 이미 있다고 가정. 여기서는 번역과 리소스, UX만 다룸)*

이 문서는 “디스코드 번역 해줘” 류의 명령이 들어왔을 때, **번역→클립보드 복사→알림(Toast+미니창)**까지 매끄럽게 처리하고, **VRAM이 부족하면 자동으로 안전하게 모델을 바꿔 태우는** 규칙을 자세히 명시합니다. 이 문서만 Codex에 넣어도 팀이 구현·테스트까지 할 수 있게 설계/사양을 모두 자연어로 기술했습니다.

---

## 0) 목표/범위

* 입력: (STT가 넘겨주는) 텍스트 문장 또는 사용자가 직접 친 문장.
* 출력: 목표 언어로 번역된 문자열을 **클립보드에 즉시 복사**하고, **Toast + 미니창**으로 안내.
* 방향 규칙:
  * **한국어 → 타언어**: **번역 툴 체인(MT 또는 LLM API)** 사용.
  * **타언어 → 한국어**: **LLM만** 사용(툴 호출 없음).
* VRAM 정책: **최대 두 개의 모델만 실시간 상주**(번역 1 + 다른 1), **부족 시 자동 언로드/강등/폴백**.

---

## 1) 의도/언어 인식 규칙

### 1.1 트리거 문구

* “디스코드 번역 해줘”, “영어/일본어/중국어로 번역해줘”, “번역해”, “번역” 등.
* 트리거가 발견되면 **번역 모드**로 진입.

### 1.2 목표 언어 추출

* 정규식 예시(자연어 규칙 설명):
  “(영어|영문|English|EN) / (일본어|일문|Japanese|JP) / (중국어|중문|Chinese|CN|간체|번체)” 등 키워드를 찾아 **목표 언어**로 매핑.
* 언급이 없으면 **기본값: 영어(en)**.

### 1.3 원문 언어 판정(간단 휴리스틱)

* 한글 코드포인트(가-힣)가 포함되어 있으면 **원문=한국어**로 간주.
* 없으면 **원문=비한국어**(영/일/중 중 하나)로 간주.
  ※ 고급 감지는 불필요. 애매하면 LLM에게 “한국어로 번역”만 지시.

---

## 2) 번역 엔진 선택 정책

### 2.1 방향에 따른 선택

* **KO → X(EN/JA/ZH)**:
  1순위 **MT 전용 엔진**(예: NLLB-200/CT2 서비스).
  실패/불가 시 **LLM 엔진**(OpenAI 호환)로 폴백.
* **X → KO**:
  **LLM만** 사용. 툴(별도 MT)은 호출하지 않음.

### 2.2 품질·스타일 지침

* LLM 번역 시스템 메시지(개념):
  “의미와 톤을 보존하여 자연스러운 한국어로 번역하라. 존댓말/반말은 문맥에 맞추되, 디스코드 공유용으로 간결하게.”
* MT 사용 시 용어 통일이 필요하면 후편집으로 LLM에 “용어집 적용” 프롬프트를 덧대 2차 가공(선택).

---

## 3) VRAM 정책 로직 (핵심)

### 3.1 용어/전제

* **프로바이더**: 번역/LLM을 호스팅하는 백엔드.
  예: LM Studio(서버 모드), ollama-openai, vLLM, 또는 NLLB-CT2 번역 마이크로서비스.
* **모델 메타**: 모델별 **대략적 VRAM 요구량(MiB)**·**로딩 시간**·**대체 후보**를 표로 관리.
  예) `qwen-4b-int4 ~ 4500MiB`, `qwen-7b-int4 ~ 7000MiB`, `nllb-3.3b-int8 ~ 3800MiB`, `nllb-600m-int8 ~ 1200MiB` *(수치는 운영 과정에서 실제 측정치로 보정)*

### 3.2 상주 개수/상한

* **동시 상주 최대 2개**(번역 1 + 기타 1).
* **소프트 상한**: 총 VRAM의 **90%**.
* 이 상한을 넘길 것으로 예측되면 **모델 교체/언로드**를 시도.

### 3.3 모델 로딩 의사결정(자연어 의사코드)

1. “번역” 요청이 들어오면 **현 모델 셋과 VRAM 사용량**(NVML 등으로)과 **후보 모델의 예상 VRAM**을 합산해 본다.
2. 합계가 **소프트 상한 이내**면 그대로 로드/사용.
3. **초과**면, 아래 순서로 조치:
   * **언로드 후보 선정**: 현재 상주 중인 모델 중,
     ① **가장 큰 VRAM**을 쓰면서 ② **최근 N초간 사용 빈도가 낮은** 모델을 우선 제거.
     (히스테리시스: 즉시 재로딩 방지 위해 **30~60초 쿨다운**)
   * 언로드 후에도 **여전히 초과**면, **강등 규칙**을 적용:
     예) `qwen-7b → qwen-4b`, `nllb-3.3b → nllb-600m`.
   * 그래도 초과면 **CPU 폴백** 또는 **외부 번역 API**로 일시 전환.
4. 모델이 교체/강등되면 **UI 배지**로 “경량 엔진 전환(품질↓)”을 3초 표기.
5. 최근 **M분간 번역 요청이 없으면** 번역 모델은 자동 언로드(메모리 환수).

### 3.4 프로바이더별 운용 팁

* **LM Studio**: 동시 다중 모델 상주가 제한될 수 있으므로,
  * “2개 필요” 시 인스턴스(프로세스) 2개로 분할 운영하거나,
  * 두 번째 모델은 **ollama-openai/vLLM** 등 **다른 프로바이더**로 붙인다.
* **NLLB-CT2**: 별도 프로세스(번역 전용)를 백그라운드 서비스로 상주시켜 경량 호출.
  * VRAM 여유가 없으면 **CPU 모드**로 전환 가능(지연↑).

### 3.5 스로틀/큐잉

* 번역 요청 큐는 **최대 3건**. 넘어가면 **즉시 “혼잡” 안내**(사용자 경험 보호).
* 큐 지연이 2초를 넘기면 **경량 엔진 강등**을 우선 고려.

---

## 4) 클립보드 복사 & 알림 UX

### 4.1 복사 대상

* **기본: 모바일**(안드로이드 앱) → OS 클립보드에 `setString(번역문)`.
* **옵션: PC**(데스크톱 디스코드에 붙여넣기할 때) → 게이트웨이가 OS 클립보드에 복사.
  * 설정값 `clipboard.device = android | windows`

### 4.2 알림

* **Toast**: “[영어] 번역이 클립보드에 복사되었어요.”(2.5초)
* **미니창**:
  * 미리보기(앞 80자), “디스코드 열기” 버튼, “다시 번역”, “닫기”.
  * 10초 후 자동 축소(점 아이콘). 탭 시 재확대.

### 4.3 실패 처리

* 권한 미부여: “클립보드 접근 권한이 필요합니다” + 설정 이동.
* 복사 충돌: 재시도 버튼 제공.
* 딥링크 실패(앱 전환 불가): 대체 안내 텍스트 표기.

---

## 5) 구성(설정) 키

* `translation.default_target` — 기본 목표 언어(미지정 시), 기본 `"en"`.
* `translation.ko_to_x_engine` — `"nllb"` 또는 `"llm"`.
* `translation.x_to_ko_engine` — 항상 `"llm"`.
* `translation.nllb_endpoint` — CT2 번역 서비스 주소.
* `translation.llm_endpoint` — OpenAI 호환 서버 주소.
* `translation.llm_model_ko_in` — X→KO 시 사용할 LLM 모델명(예: `qwen2.5-4b-instruct`).
* `clipboard.device` — `"android"` 또는 `"windows"`.
* `ui.toast_duration_ms` — 기본 2500.
* `ui.mini_sheet_timeout_ms` — 기본 10000.
* `scheduler.vram_soft_cap_ratio` — 기본 0.90.
* `scheduler.max_loaded_models` — 기본 2.
* `scheduler.fallbacks` — 강등 사다리(예: `qwen-7b→4b`, `nllb-3.3b→600m`).
* `models.metadata` — 모델별 예상 VRAM/로드시간/우선순위 테이블.

---

## 6) 처리 흐름

1. **문장 수신**(STT final 또는 사용자가 입력).
2. **의도/목표 언어 판정**: 트리거 키워드 및 언어 키워드 분석.
3. **원문 언어 판정**: 한글 포함 여부로 KO/비KO 구분.
4. **엔진 선택**:
   * KO→X: MT 우선, 실패 시 LLM.
   * X→KO: LLM.
5. **VRAM 정책 적용**:
   * 후보 모델 로딩 전 “예상 VRAM + 현 사용량”을 상한과 비교.
   * 필요 시 언로드/강등/폴백을 순서대로 적용.
6. **번역 실행** → 문자열 획득.
7. **클립보드 복사**(설정된 기기).
8. **Toast + 미니창** 표시.
9. **로그** 기록: 방향, 엔진 종류, 경과(ms), VRAM 조치 내역.

---

## 7) 품질·성능 기준

* **지연 목표**(텍스트 입력→Toast): p50 ≤ 1.2s, p95 ≤ 2.5s.
* **정확도**: 예시 문장 30개에서 의미 왜곡 없음.
* **VRAM 안전성**: VRAM 소프트 상한 초과 시에도 **프로세스 OOM 없이** 번역 성공률 ≥ 99%.

---

## 8) 테스트 시나리오

### 8.1 기능

* “디스코드 번역 해줘” → 기본 언어(en)로 번역, 클립보드 복사, 알림 2.5초.
* “영어로 번역해줘 / 일본어로 번역해줘 / 중국어로 번역해줘(간체)” → KO→X 정상 동작.
* “Translate this to Korean” → X→KO (LLM만) 경로 사용됨을 로그에서 확인.

### 8.2 VRAM

* **정상 용량**: 상한 이하에서 모델 2개 상주.
* **한계 초과**: 4B 상주 상태에서 14B 필요 → **4B 언로드 또는 14B 강등**이 적용되는지 확인.
* **스파이크**: 연속 5건 요청 → 큐 길이 제한/강등 동작 확인.

### 8.3 클립보드/UX

* 모바일 복사 후 디스코드 앱 전환 → 붙여넣기 가능.
* PC 복사 모드 전환 시 OS 클립보드 반영.
* 권한 거부/복사 실패 시 사용자 안내.

---

## 9) 예시 문장 처리 가이드

* “마인크래프트 배틀필드 개꿀잼임 영어로 번역해줘”
  → KO→EN, MT 우선, 결과 클립보드 복사 + “영어 번역 복사됨” 토스트.
* “마인크래프트 배틀필드 개꿀잼임 일본어로 번역해줘”
  → KO→JA, MT 우선.
* “마인크래프트 배틀필드 개꿀잼임 중국어로 번역해줘”
  → KO→ZH(간체 기본), MT 우선. “번체”라는 단어가 있으면 ZH-Hant.
* “This game mode is insane, translate to Korean”
  → EN→KO, **LLM만** 사용.

---

## 10) 장애/예외 처리

* **MT 서비스 다운** → LLM로 폴백 + 배지 “폴백(품질/톤 다를 수 있음)”.
* **LLM 서버 혼잡** → 대체 LLM(경량 4B)로 강등 또는 대기 안내.
* **VRAM 스래싱**(로드↔언로드 반복) → 쿨다운 60초와 LRU 가중치로 진정.
* **클립보드 권한 없음** → 설정 이동 안내.
* **딥링크 실패** → 앱 전환 수동 안내.

---

## 11) 운영 체크리스트

* 모델 메타(VRAM/로드시간) 표를 **실측치로 주기적 업데이트**.
* 번역 품질 회귀셋(10~30문장)을 구성해 주 1회 자동 점검.
* 큐 대기 시간이 잦아지면 **기본 엔진을 경량으로** 조정.
* 로그에 번역문 저장 금지(민감정보) — 필요 시 **해시/마스킹**.

---

### 한 줄 정리

> **명령 한 마디**면 **번역→클립보드→알림**까지 자동.
> **KO→X는 MT/LLM 툴 체인**, **X→KO는 LLM만**.
> **VRAM은 2모델 상주·90% 상한**, **초과 시 언로드/강등/폴백**으로 **끊김 없이** 동작.

